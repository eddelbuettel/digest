#' Calculate a SHA1 hash of an object.
#'
#' Calculate a SHA1 hash of an object. The main difference with
#' \code{digest(x, algo = "sha1")} is that \code{sha1()} will give the same hash
#' on 32-bit and 64-bit systems. Note that the results depends on the setting of
#' \code{digits} and \code{zapsmall} when handling floating point numbers. The
#' current defaults keep \code{digits} and \code{zapsmall} as large as possible
#' while maintaining the same hash on 32 bit and 64 bit systems.
#'
#' @param x The object to calculate the SHA1
#' @param digits The approximate number of significant digits in base 10. Will
#'   be converted to a base 16 equivalent. Defaults to \code{digits = 14},
#'   expect for sha1.anova where \code{digits = 4}
#' @param zapsmall The apporixmate negative magnitute of the smallest relevant
#'   digit. Will be converted to a base 2 equivalent. Values smaller than this
#'   number are equivalent to 0. Defaults to \code{zapsmall = 7}
#'
#' @author Thierry Onkelinx
#' @export
sha1 <- function(x, digits = 14L, zapsmall = 7L){
    UseMethod("sha1")
}

#' @export
sha1.default <- function(x, digits = 14L, zapsmall = 7L) {
    stop(
        "sha1() has not method for the '",
        paste(class(x), collapse = "', '"),
        "' class",
        call. = FALSE
    )
}

#' @export
sha1.integer <- function(x, digits = 14L, zapsmall = 7L) {
    attr(x, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(x, algo = "sha1")
}

#' @export
sha1.character <- function(x, digits = 14L, zapsmall = 7L) {
    attr(x, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(x, algo = "sha1")
}

#' @export
sha1.factor <- function(x, digits = 14L, zapsmall = 7L) {
    attr(x, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(x, algo = "sha1")
}

#' @export
sha1.NULL <- function(x, digits = 14L, zapsmall = 7L) {
    digest(x, algo = "sha1")
}

#' @export
sha1.logical <- function(x, digits = 14L, zapsmall = 7L) {
    attr(x, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(x, algo = "sha1")
}

#' @export
sha1.numeric <- function(x, digits = 14L, zapsmall = 7L){
    y <- num2hex(
        x,
        digits = digits,
        zapsmall = zapsmall
    )
    attr(y, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(y, algo = "sha1")
}

#' @export
sha1.matrix <- function(x, digits = 14L, zapsmall = 7L){
    # needed to make results comparable between 32-bit and 64-bit
    if (class(x[1, 1]) == "numeric") {
        y <- matrix( #return a matrix with the same dimensions as x
            apply(
                x,
                2,
                num2hex,
                digits = digits,
                zapsmall = zapsmall
            ),
            ncol = ncol(x)
        )
        attr(y, "digest::sha1") <- list(
            class = class(x),
            digits = as.integer(digits),
            zapsmall = as.integer(zapsmall)
        )
        digest(y, algo = "sha1")
    } else {
        attr(x, "digest::sha1") <- list(
            class = class(x),
            digits = as.integer(digits),
            zapsmall = as.integer(zapsmall)
        )
        digest(x, algo = "sha1")
    }
}

#' @export
sha1.data.frame <- function(x, digits = 14L, zapsmall = 7L){
    if (length(x)) {
        # needed to make results comparable between 32-bit and 64-bit
        y <- vapply(
            x,
            sha1,
            digits = digits,
            zapsmall = zapsmall,
            FUN.VALUE = NA_character_
        )
    } else {
        y <- x
    }
    attr(y, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(y, algo = "sha1")
}

#' @export
sha1.list <- function(x, digits = 14L, zapsmall = 7L){
    if (length(x)) {
        # needed to make results comparable between 32-bit and 64-bit
        y <- vapply(
            x,
            sha1,
            digits = digits,
            zapsmall = zapsmall,
            FUN.VALUE = NA_character_
        )
    } else {
        y <- x
    }
    attr(y, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(y, algo = "sha1")
}

#' @export
sha1.POSIXlt <- function(x, digits = 14L, zapsmall = 7L) {
    y <- do.call(
        data.frame,
        lapply(as.POSIXlt(x), unlist)
    )
    y$sec <- num2hex(y$sec, digits = digits, zapsmall = zapsmall)
    attr(y, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(y, algo = "sha1")
}

#' @export
sha1.POSIXct <- function(x, digits = 14L, zapsmall = 7L) {
    y <- sha1(as.POSIXlt(x), digits = digits, zapsmall = zapsmall)
    attr(y, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(y, algo = "sha1")
}

#' @export
sha1.anova <- function(x, digits = 4L, zapsmall = 7L){
    if (digits > 4) {
        warning(
"Hash on 32 bit might be different from hash on 64 bit with digits > 4"
        )
    }
    y <- apply(
        x,
        1,
        num2hex,
        digits = digits,
        zapsmall = zapsmall
    )
    attr(y, "digest::sha1") <- list(
        class = class(x),
        digits = as.integer(digits),
        zapsmall = as.integer(zapsmall)
    )
    digest(y, algo = "sha1")
}

#' @note not exported
num2hex <- function(x, digits = 14L, zapsmall = 7L){
    if (!is.numeric(x)) {
        stop("x is not numeric")
    }
    if (!is.integer(digits)) {
        if (!all.equal(as.integer(digits), digits)) {
            stop("digits is not integer")
        }
        digits <- as.integer(digits)
    }
    if (length(digits) != 1) {
        stop("digits must contain exactly one integer")
    }
    if (digits < 1) {
        stop("digits must be positive")
    }
    if (!is.integer(zapsmall)) {
        if (!all.equal(as.integer(zapsmall), zapsmall)) {
            stop("zapsmall is not integer")
        }
        zapsmall <- as.integer(zapsmall)
    }
    if (length(zapsmall) != 1) {
        stop("zapsmall must contain exactly one integer")
    }
    if (zapsmall < 1) {
        stop("zapsmall must be positive")
    }

    if (length(x) == 0) {
        return(character(0))
    }
    x.na <- is.na(x)
    if (all(x.na)) {
        return(x)
    }
    output <- rep(NA, length(x))

    x.hex <- sprintf("%a", x[!x.na])
    exponent <- as.integer(gsub("^.*p", "", x.hex))

    # detect "small" numbers
    zapsmall.hex <- floor(log2(10 ^ -zapsmall))
    zero <- x.hex == sprintf("%a", 0) | exponent <= zapsmall.hex
    if (any(zero)) {
        output[!x.na][zero] <- "0"
        if (all(zero)) {
            return(output)
        }
    }

    digits.hex <- ceiling(log(10 ^ digits, base = 16))
    mantissa <- x.hex[!zero] # select "large" numbers
    # select mantissa
    mantissa <- gsub(mantissa, pattern = ".*x1\\.{0,1}", replacement = "")
    # select mantissa
    mantissa <- gsub(mantissa, pattern = "p.*$", replacement = "")
    mantissa <- substring(mantissa, 1, digits.hex) # select required precision
    # remove potential trailing zero's
    mantissa <- gsub(mantissa, pattern = "0*$", replacement = "")
    negative <- ifelse(grepl(x.hex[!zero], pattern = "^-"), "-", "")
    output[!x.na][!zero] <- paste0(negative, mantissa, " ", exponent[!zero])
    return(output)
}
